import{_ as a,c as n,a as l,o as s}from"./app-CUeCZAbe.js";const i={};function r(t,e){return s(),n("div",null,e[0]||(e[0]=[l(`<h1 id="缓存池" tabindex="-1"><a class="header-anchor" href="#缓存池"><span>缓存池</span></a></h1><h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h1><h2 id="作用" tabindex="-1"><a class="header-anchor" href="#作用"><span>作用</span></a></h2><ul><li>加速读: 数据读取先查缓存，没有再查磁盘</li><li>加速写：数据修改后，先写入缓存, 再找时间再统一写入磁盘</li></ul><h1 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h1><h2 id="局部性原理" tabindex="-1"><a class="header-anchor" href="#局部性原理"><span><strong>局部性原理</strong></span></a></h2><ul><li>空间局部性：某页被访问，其相邻页也可能会被访问 -&gt; 预读机制</li><li>时间局部性：某页最近被访问过，将来也很可能会被访问 -&gt; LRU</li><li>目的是减少磁盘 IO 次数，尽可能的让读写落到内存中</li><li>按数据页读取，存到内存中</li><li></li></ul><h2 id="有关预读" tabindex="-1"><a class="header-anchor" href="#有关预读"><span>有关预读</span></a></h2><p><a href="https://www.cnblogs.com/geaozhang/p/7397699.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/geaozhang/p/7397699.html</a></p><h3 id="线性预读" tabindex="-1"><a class="header-anchor" href="#线性预读"><span>线性预读</span></a></h3><p>线性预读是以 extend 为单位的。通过判断当前的 extend 中的数据是否是连续访问的，并以此来预测是否有必要把下一个 extend 提前从磁盘文件中读取出来，加载到 buffer pool 中。</p><h4 id="相关配置" tabindex="-1"><a class="header-anchor" href="#相关配置"><span>相关配置</span></a></h4><ul><li>innodb_read_ahead_threshold： 当一个 extend 中，大于等于 innodb_read_ahead_threshold 个 page 是被连续访问的时候，就预先加载下一个 extend 的数据。默认值是 56，最大值 64</li></ul><h2 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h2><p>缓存池结构</p><p>缓存池实例结构</p><p>缓存池实现上有三种链表结构</p><ul><li>Free 链表：管理空白页</li><li>LRU 链表：管理已经有数据的页</li><li>Flush 链表：管理脏页，脏页同时也会在 LRU 链表中</li><li>读取数据未命中缓存，会向 Free 链表要一页，加入到 LRU 链表中</li><li>内存中的页被修改，会扔到 Flush 链表一份</li><li>Flush 链表的页被回存了，会在 Flush 链表中删除</li></ul><h2 id="淘汰策略" tabindex="-1"><a class="header-anchor" href="#淘汰策略"><span>淘汰策略</span></a></h2><p>缓存大小有限，需要一定的淘汰策略</p><p>基础淘汰策略:LRU(最近最少使用)</p><h3 id="冷热数据分离" tabindex="-1"><a class="header-anchor" href="#冷热数据分离"><span>冷热数据分离</span></a></h3><p>原有纯 LRU 方案可能会存在以下问题:</p><ul><li>预读失效：预读会加载相邻页，有可能相邻页并没有再被访问，却挤掉了被频繁访问的页</li><li>缓冲池污染: 存在扫描的 sql 请求，此请求得到的数据不会被频繁使用，占用页巨多，却将其他的缓存页给挤掉了</li></ul><p>因此引入了 冷热数据分离的设计：</p><ul><li>当数据页第一次被加载到缓冲池中的时候，先将其放到冷数据区域的链表头部，1s（由 innodb_old_blocks_time 参数控制） 后该缓存页被访问了再将其移至热数据区域的链表头部。</li><li>Mysql 中优化为热数据区的后 3/4 部分被访问后才将其移动到链表头部去，对于前 1/4 部分的缓存页被访问了不会进行移动。</li></ul><h1 id="配置" tabindex="-1"><a class="header-anchor" href="#配置"><span>配置</span></a></h1><ul><li>innodb_buffer_pool_chunk_size</li><li>innodb_buffer_pool_instances</li><li>innodb_buffer_pool_size</li></ul><h2 id="可在线配置" tabindex="-1"><a class="header-anchor" href="#可在线配置"><span>可在线配置</span></a></h2><p>修改缓存池总大小，单位字节，必须为 innodb_buffer_pool_chunk_size*innodb_buffer_pool_instances 的倍数。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">SET GLOBAL innodb_buffer_pool_size=8589934592;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>使用 Innodb_buffer_pool_resize_status 报告缓冲池大小调整的进展</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">mysql&gt; SHOW STATUS WHERE Variable_name =&#39;InnoDB_buffer_pool_resize_status&#39;;</span>
<span class="line">+----------------------------------+-------+</span>
<span class="line">| Variable_name                    | Value |</span>
<span class="line">+----------------------------------+-------+</span>
<span class="line">| Innodb_buffer_pool_resize_status |       |</span>
<span class="line">+----------------------------------+-------+</span>
<span class="line">1 row in set (0.01 sec)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="只可离线配置" tabindex="-1"><a class="header-anchor" href="#只可离线配置"><span>只可离线配置</span></a></h2><p>innodb_buffer_pool_chunk_size</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">[mysqld]</span>
<span class="line">innodb_buffer_pool_chunk_size = 134217728</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="监控" tabindex="-1"><a class="header-anchor" href="#监控"><span>监控</span></a></h1><p>查看统计信息</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">show engine innodb status</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h1 id="应用" tabindex="-1"><a class="header-anchor" href="#应用"><span>应用</span></a></h1><h1 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h1><p><a href="https://bbs.huaweicloud.com/blogs/107748" target="_blank" rel="noopener noreferrer">MySQL 源码学习(六):线性预读-云社区-华为云</a></p><p><a href="https://www.cnblogs.com/geaozhang/p/7397699.html" target="_blank" rel="noopener noreferrer">关于 MySQL buffer pool 的预读机制 - GeaoZhang - 博客园</a></p><p><a href="https://juejin.cn/post/6917113558341795848" target="_blank" rel="noopener noreferrer">MySQL 中的这个池子--缓冲池(buffer pool)，真的强! - 掘金</a></p><p><a href="https://cloud.tencent.com/developer/article/1779059" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1779059</a></p><p><a href="http://mysql.taobao.org/monthly/2016/05/04/" target="_blank" rel="noopener noreferrer">MySQL · 特性分析 · innodb buffer pool 相关特性</a></p><p><a href="https://zhuanlan.zhihu.com/p/65811829" target="_blank" rel="noopener noreferrer">[玩转 MySQL 之十]InnoDB Buffer Pool 详解</a></p>`,47)]))}const p=a(i,[["render",r]]),h=JSON.parse('{"path":"/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E7%BC%93%E5%AD%98%E6%B1%A0.html","title":"缓存池","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"作用","slug":"作用","link":"#作用","children":[]},{"level":2,"title":"局部性原理","slug":"局部性原理","link":"#局部性原理","children":[]},{"level":2,"title":"有关预读","slug":"有关预读","link":"#有关预读","children":[{"level":3,"title":"线性预读","slug":"线性预读","link":"#线性预读","children":[]}]},{"level":2,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[]},{"level":2,"title":"淘汰策略","slug":"淘汰策略","link":"#淘汰策略","children":[{"level":3,"title":"冷热数据分离","slug":"冷热数据分离","link":"#冷热数据分离","children":[]}]},{"level":2,"title":"可在线配置","slug":"可在线配置","link":"#可在线配置","children":[]},{"level":2,"title":"只可离线配置","slug":"只可离线配置","link":"#只可离线配置","children":[]}],"git":{},"filePathRelative":"数据库/Mysql/缓存池.md"}');export{p as comp,h as data};
