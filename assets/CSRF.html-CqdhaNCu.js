import{_ as a,c as i,a as n,o as s}from"./app-CDWhkXlS.js";const t="/wiki/%E6%9D%82%E9%A1%B9/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/static/KrxMbQVP0or4Bux7p21cTjmfnLf.png",r={};function p(l,e){return s(),i("div",null,e[0]||(e[0]=[n('<h1 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf"><span>CSRF</span></a></h1><h3 id="攻击原理" tabindex="-1"><a class="header-anchor" href="#攻击原理"><span>攻击原理</span></a></h3><p><img src="'+t+`" alt=""></p><p>如上图所示，简单地说，就是攻击网站内部 B 嵌入了对被攻击网站 A 的请求。如果 A 已经是登录状态，且请求时携带了自身的 cookie 信息，A 网站可能会认为 B 中发起对 A 网站的请求也是一个合理请求，从而进行相应。</p><p>攻击网站构造的请求可能是嵌入在 img 中，也可能是自动执行的脚本，GET 形式的请求较为常见，不过也会有 POST 形式的请求。</p><h3 id="危害" tabindex="-1"><a class="header-anchor" href="#危害"><span>危害</span></a></h3><p>会发起用户预期之外的请求，如对银行网站会造成意料之外的消费</p><h3 id="防范方法" tabindex="-1"><a class="header-anchor" href="#防范方法"><span>防范方法</span></a></h3><h4 id="token-校验" tabindex="-1"><a class="header-anchor" href="#token-校验"><span>token 校验</span></a></h4><p>服务端渲染浏览器表单的时候，在一个 hidden 字段中嵌入一个随机的 token 值，当接收到请求后，服务端会对这个 token 进行校验。</p><p>攻击网站无法获取到这个 token，因此也就没法通过表单校验了</p><h4 id="refer-头校验" tabindex="-1"><a class="header-anchor" href="#refer-头校验"><span>Refer 头校验</span></a></h4><p>HTTP 请求头中的 Refer 会记录请求发起 URL 地址，如果请求是在 B 网站发出的，则记录的 Refer 则会记录 B 的 URL，服务端可以判断这个字段值是否属于 A 的地址，来决定是否接受该请求。</p><p>一般可以把 Refer 头的校验统一放入中间件即可</p><p>不过要注意 Refer 是否能被篡改的问题，现代浏览器似乎都不容易被篡改了</p><h4 id="cookie-samesite-选项" tabindex="-1"><a class="header-anchor" href="#cookie-samesite-选项"><span>Cookie samesite 选项</span></a></h4><p>chrome 较新的版本已经引入了 samesite 选项。其作用是决定第三方网站发起的请求是否进行禁用。</p><p>其有三个选项:</p><ul><li>Strict</li><li>Lax</li><li>None</li></ul><p>Strict: 完全禁止第三方 Cookie</p><p>Lax: 部分禁止第三方 Cookie</p><p>None: 不禁止第三方 Cookie，但必须与 Secure 选项搭配（即要求 Cookie 必须通过 HTTPS 协议发送）</p><p>具体信息如下表所示</p><p>当浏览器支持了这个特性，只要我们设置了</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">Set-Cookie: CookieName=CookieValue; SameSite=Strict;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>便可以杜绝 CSRF 攻击</p>`,26)]))}const c=a(r,[["render",p]]),h=JSON.parse('{"path":"/%E6%9D%82%E9%A1%B9/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/CSRF.html","title":"CSRF","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"攻击原理","slug":"攻击原理","link":"#攻击原理","children":[]},{"level":3,"title":"危害","slug":"危害","link":"#危害","children":[]},{"level":3,"title":"防范方法","slug":"防范方法","link":"#防范方法","children":[]}],"git":{},"filePathRelative":"杂项/网络安全/CSRF.md"}');export{c as comp,h as data};
