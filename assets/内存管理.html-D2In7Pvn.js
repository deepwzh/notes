import{_ as e,c as l,a,o as t}from"./app-bElOgxFi.js";const n={};function r(i,o){return t(),l("div",null,o[0]||(o[0]=[a('<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理"><span>内存管理</span></a></h1><p><a href="https://binglau7.github.io/2017/01/23/Python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/#Block" target="_blank" rel="noopener noreferrer">Python 内存管理机制——内存模型 | 村里最好的博客</a></p><p><a href="https://zikcheng.com/2022-05-22-python-memory-allocator" target="_blank" rel="noopener noreferrer">Python 中的内存管理 | zikcheng</a></p><h2 id="内存申请" tabindex="-1"><a class="header-anchor" href="#内存申请"><span>内存申请</span></a></h2><ol><li>如果没有可用的 arena 就重新申请一个</li><li>从可用的 arena 中分配一个新的 pool</li><li>从分配的 pool 中分配空闲的 block</li></ol><h2 id="内存释放" tabindex="-1"><a class="header-anchor" href="#内存释放"><span>内存释放</span></a></h2><ol><li>计算地址 p 所在 pool 首地址，前文介绍过每个 pool 首地址都是 POOL_SIZE 的整数倍，所以将 p 的低位置 0 就得到了 pool 的地址</li><li>address_in_range(p, pool) 判断 p 是否是由 pool 分配的，如果不是直接返回</li><li>将 p 指向的 block 释放掉，被 <code>pool-&gt;freeblock</code> 回收</li><li>如果 pool 开始为 full 状态，那么回收 block 之后就是 used 状态，调用函数 <code>insert_to_usedpool(pool)</code> 将其置为 <code>usedpools[size+size]</code> 的头结点。这里的策略跟 usable_arenas 一样，优先使用快满的 pool，让比较空闲的 pool 有较高的概率被释放掉。</li><li>如果 pool 回收 block 之后变成 empty 状态，需要调用 <code>insert_to_freepool(pool)</code> 将 pool 也释放掉</li></ol>',7)]))}const s=e(n,[["render",r]]),c=JSON.parse('{"path":"/Python/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"内存申请","slug":"内存申请","link":"#内存申请","children":[]},{"level":2,"title":"内存释放","slug":"内存释放","link":"#内存释放","children":[]}],"git":{},"filePathRelative":"Python/内存管理.md"}');export{s as comp,c as data};
