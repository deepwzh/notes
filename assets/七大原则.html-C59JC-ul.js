import{_ as r,c as e,a as n,o as a}from"./app-B2W6m6qX.js";const l={};function d(s,t){return a(),e("div",null,t[0]||(t[0]=[n('<h1 id="七大原则" tabindex="-1"><a class="header-anchor" href="#七大原则"><span>七大原则</span></a></h1><table><tr><td>标记<br></td><td>设计模式原则名称<br></td><td>简单定义<br></td></tr><tr><td>OCP<br></td><td>开闭原则<br></td><td>对扩展开放，对修改关闭<br></td></tr><tr><td>SRP<br></td><td>单一职责原则<br></td><td>一个类只负责一个功能领域中的相应职责<br><br></td></tr><tr><td>LSP<br></td><td>里氏代换原则<br></td><td>所有引用基类的地方必须能透明地使用其子类的对象<br></td></tr><tr><td>**DIP**<br></td><td>**依赖倒转原则**<br></td><td>**依赖于抽象，不能依赖于具体实现**<br></td></tr><tr><td>ISP<br></td><td>接口隔离原则<br></td><td>类之间的依赖关系应该建立在最小的接口上<br></td></tr><tr><td>CARP<br><br></td><td>合成/聚合复用原则<br></td><td>尽量使用合成/聚合，而不是通过继承达到复用的目的<br></td></tr><tr><td>LOD<br></td><td>迪米特法则<br></td><td>一个软件实体应当尽可能少的与其他实体发生相互作用<br></td></tr><tr><td><br></td><td><br></td><td><br></td></tr></table><p>其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则就是我们平常熟知的 <strong>SOLID</strong>。</p><h2 id="开闭原则" tabindex="-1"><a class="header-anchor" href="#开闭原则"><span>开闭原则</span></a></h2><ul><li>实现开闭原则依赖于依赖倒置原则，而要实现依赖倒置，需要先进行抽象化，抽象化的具体指导原则即是里氏替换原则</li></ul><h2 id="里氏替换原则" tabindex="-1"><a class="header-anchor" href="#里氏替换原则"><span>里氏替换原则</span></a></h2><ul><li>里氏代换原则是实现<strong>开闭原则</strong>的重要方式之一</li><li>所有能用父类的地方，都能替换成子类；反之则不成立</li></ul><h3 id="意义" tabindex="-1"><a class="header-anchor" href="#意义"><span>意义</span></a></h3><ul><li>里氏代换原则是实现开闭原则的基础，告诉我们在设计程序的时候进可能使用基类进行对象的定义和引用，在运行时再决定基类的具体子类型。</li></ul><h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则"><span>单一职责原则</span></a></h2><p><strong>指一个类或者模块应该有且只有一个改变的原因</strong>。如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力</p><h2 id="合成-聚合复用原则" tabindex="-1"><a class="header-anchor" href="#合成-聚合复用原则"><span>合成/聚合复用原则</span></a></h2><p><strong>尽量使用合成/聚合，而不是通过继承达到复用的目的</strong>。</p><p>合成/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向内部持有的这些对象的委派达到复用已有功能的目的，而不是通过继承来获得已有的功能。</p><p>如果有阅读过《Effective Java 2nd》的同学就知道，此书也建议慎用继承。一般情况下，<strong>只有明确知道派生类和基类满<strong><strong>IS A</strong></strong>的时候才选用继承，当满足<strong><strong>HAS A</strong></strong>或者不能判断的情况下应该选用合成/聚合。</strong></p><h2 id="迪米特法则" tabindex="-1"><a class="header-anchor" href="#迪米特法则"><span><strong>迪米特法则</strong></span></a></h2><p>有时候也叫做最少知识原则（Least Knowledge Principle，LKP），它的定义是：一个软件实体应当尽可能少地与其他实体发生相互作用。<strong>每一个软件单位对其他的单位都只有最少的知识</strong>，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。</p><p>迪米特法则<strong>不希望类之间建立直接的联系</strong>。如果真的有需要建立联系，也希望能通过它的<strong>友元类（中间类或者跳转类</strong>）来转达。</p><h2 id="接口隔离原则" tabindex="-1"><a class="header-anchor" href="#接口隔离原则"><span>接口隔离原则</span></a></h2><p><strong>1）一个类对另外一个类的依赖性应当是建立在最小的接口上的。</strong></p><p><strong>2）客户端程序不应该依赖它不需要的接口方法（功能）。</strong></p><blockquote><p>在实际应用中，会遇到如下问题：比如，我需要一个能适配多种类型数据库的 DAO 实现，那么首先应实现一个数据库操作的接口，其中规定一些数据库操作的基本方法，比如连接数据库、增删改查、关闭数据库等。这是一个最少功能的接口。对于一些 MySQL 中特有的而其他数据库里并不存在的或性质不同的方法，如 PHP 里可能用到的 MySQL 的 pconnect 方法，其他数据库里并不存在和这个方法相同的概念，这个方法也就不应该出现在这个基本的接口里，那这个基本的接口应该有哪些基本的方法呢？PDO 已经告诉你了。 PDO 是一个抽象的数据库接口层，它告诉我们一个基本的数据库操作接口应该实现哪些基本的方法。接口是一个高层次的抽象，所以接口里的方法都应该是通用的、基本的、不易变化的。 还有一个问题，那些特有的方法应该怎么实现？根据 ISP 原则，这些方法可以在别一个接口中存在，让这个“异类”同时实现这两个接口。 对于接口的污染，可以考虑这两条处理方式：</p><ul><li>利用委托分离接口。</li><li>利用多继承分离接口。 委托模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理，如策略模式、代理模式等中都应用到了委托的概念。</li></ul></blockquote><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h3><p><a href="https://www.runoob.com/note/39073" target="_blank" rel="noopener noreferrer">https://www.runoob.com/note/39073</a></p><h2 id="参考-1" tabindex="-1"><a class="header-anchor" href="#参考-1"><span>参考</span></a></h2><p><a href="https://cloud.tencent.com/developer/article/1650116" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1650116</a></p>',26)]))}const i=r(l,[["render",d]]),h=JSON.parse('{"path":"/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99.html","title":"七大原则","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"开闭原则","slug":"开闭原则","link":"#开闭原则","children":[]},{"level":2,"title":"里氏替换原则","slug":"里氏替换原则","link":"#里氏替换原则","children":[{"level":3,"title":"意义","slug":"意义","link":"#意义","children":[]}]},{"level":2,"title":"单一职责原则","slug":"单一职责原则","link":"#单一职责原则","children":[]},{"level":2,"title":"合成/聚合复用原则","slug":"合成-聚合复用原则","link":"#合成-聚合复用原则","children":[]},{"level":2,"title":"迪米特法则","slug":"迪米特法则","link":"#迪米特法则","children":[]},{"level":2,"title":"接口隔离原则","slug":"接口隔离原则","link":"#接口隔离原则","children":[{"level":3,"title":"参考","slug":"参考","link":"#参考","children":[]}]},{"level":2,"title":"参考","slug":"参考-1","link":"#参考-1","children":[]}],"git":{},"filePathRelative":"杂项/设计模式/七大原则.md"}');export{i as comp,h as data};
