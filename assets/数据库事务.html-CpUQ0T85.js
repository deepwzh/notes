import{_ as i,c as t,a as e,o as s}from"./app-BCPqHasI.js";const a="/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/static/Mg4PbEbr1oz2ObxQ5t8cIicsnzB.png",E={};function c(p,l){return s(),t("div",null,l[0]||(l[0]=[e('<h1 id="数据库事务" tabindex="-1"><a class="header-anchor" href="#数据库事务"><span>数据库事务</span></a></h1><p>数据库事务的 4 个特性：</p><ul><li>原子性：事务中的操作要么不做，要么全做</li><li>一致性：事务从一个正确的状态可以迁移到另一个正常的状态</li><li>隔离性：事务之间不互相影响</li><li>持久性：事务提交后可以持久化存储</li></ul><p>事务的目的是为了保障一致性，原子性，隔离性，持久性都是为了一致性服务的</p><p>隔离性是指事务不互相影响。</p><p>影响大体分为以下几种</p><ul><li>脏读：一个事务中读到另一个事务中未提交的数据</li><li>不可重复读: 同一事务中多次执行相同的 select, 数据改变（因为其他事务进行了 update 并提交）</li><li>幻读: 同一事务多次进行 select, 数据条目增加（因为其他事务进行了 insert 并提交)</li><li>可重复读: 同一事务，多次 select 也不会改变数据</li></ul><p>为了解决上边的问题，引入了四种隔离性:</p><ul><li>READ UNCOMMITTED 读未提交: 可以读取为提交的数据，即可以脏读，幻读，不可重复读</li><li>READ COMMITTED(RC) 读已提交: 只能读取已经提交的数据，不可以脏读，可以幻读和不可重复读</li><li>REPEATABLE READ(RR) 可重复读: 同一事务中多次 select，数据也不会被修改，允许幻读，不允许脏读，不可重复读</li><li>SERIALIZABLE: 串行化，不允许幻读，脏读，不可重复读</li><li></li></ul><p><img src="'+a+'" alt=""></p>',10)]))}const n=i(E,[["render",c]]),o=JSON.parse('{"path":"/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1.html","title":"数据库事务","lang":"zh-CN","frontmatter":{},"headers":[],"git":{},"filePathRelative":"数据库/Mysql/数据库事务.md"}');export{n as comp,o as data};
