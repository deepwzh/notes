import{_ as l,c as o,a,o as i}from"./app-DbdC6nwX.js";const n={};function t(c,e){return i(),o("div",null,e[0]||(e[0]=[a('<h1 id="调度" tabindex="-1"><a class="header-anchor" href="#调度"><span>调度</span></a></h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>Python 的 <code>asyncio</code> 库提供了一种基于事件循环的异步编程模型，其核心是无栈协程（Stackless Coroutine）。无栈协程具有以下特性：</p><ul><li><strong>单线程事件循环</strong>：<code>asyncio</code> 在单线程上创建一个事件循环，用于调度协程的执行。</li><li><strong>协作式多任务</strong>：协程只有在主动交出控制权（如通过 <code>await</code>）时，事件循环才能调度其他协程。</li><li><strong>异步等待</strong>：使用 <code>await</code> 调用可调度的对象（如协程、<code>Future</code>、<code>Task</code>），并获取其结果。</li></ul><h2 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环"><span>事件循环</span></a></h2><p>事件循环是 <code>asyncio</code> 的核心组件，负责管理和调度所有异步任务。其工作原理如下：</p><ol><li><strong>检查调度堆</strong>：将到期的定时任务移动到就绪堆。</li><li><strong>处理 I/O 事件</strong>：通过 <code>select</code> 系统调用监听 I/O 事件，将就绪的 I/O 任务移动到就绪堆。</li><li><strong>执行就绪任务</strong>：从就绪堆中取出任务并执行。</li></ol><p>事件循环通过不断重复上述步骤，实现异步任务的调度和执行。</p><hr><h2 id="调度的对象" tabindex="-1"><a class="header-anchor" href="#调度的对象"><span>调度的对象</span></a></h2><p>在 <code>asyncio</code> 中，协程可以调度的对象包括以下几种：</p><ol><li><p><strong>协程（Coroutine）</strong>：</p><ul><li>使用 <code>async def</code> 定义的函数，可以通过 <code>await</code> 暂停和恢复执行。</li><li>协程本身是一个可等待对象，但不能直接被调度，需要封装为 <code>Task</code>。</li></ul></li><li><p><strong>Future</strong>：</p><ul><li>表示一个异步操作的最终结果。</li><li>通常由低级 API 使用，开发者更多使用 <code>Task</code>。</li></ul></li><li><p><strong>Task</strong>：</p><ul><li>是 <code>Future</code> 的子类，封装了一个协程。</li><li>代表一个正在运行的协程，事件循环会调度其执行。</li></ul></li></ol><p>这些对象都可以通过 <code>await</code> 进行等待调用。</p><h2 id="调度结构" tabindex="-1"><a class="header-anchor" href="#调度结构"><span>调度结构</span></a></h2><p>事件循环通过两个核心数据结构管理协程任务：<strong>就绪堆</strong>和<strong>调度堆</strong>。</p><h2 id="就绪堆-ready-queue" tabindex="-1"><a class="header-anchor" href="#就绪堆-ready-queue"><span>就绪堆（Ready Queue）</span></a></h2><ul><li><p><strong>作用</strong>：存储当前可以立即执行的协程任务。</p></li><li><p><strong>特点</strong>：</p><ul><li>任务按 FIFO（先进先出）的顺序执行。</li><li>当协程遇到 <code>await</code> 并暂停时，事件循环会从就绪堆中取出下一个任务执行。</li></ul></li><li><p><strong>加入时机</strong>：</p><ul><li>使用 <code>call_soon()</code> 或 <code>call_soon_threadsafe()</code> 时，协程会加入就绪堆。</li><li>I/O 事件完成或定时任务到期时，相关任务会加入就绪堆。</li></ul></li></ul><h2 id="调度堆-scheduled-heap" tabindex="-1"><a class="header-anchor" href="#调度堆-scheduled-heap"><span>调度堆（Scheduled Heap）</span></a></h2><ul><li><p><strong>作用</strong>：存储需要延迟执行的协程任务，通常用于定时任务。</p></li><li><p><strong>特点</strong>：</p><ul><li>任务按时间戳排序，堆顶的任务是下一个即将到期的任务。</li><li>事件循环会定期检查调度堆，将到期的任务移动到就绪堆。</li></ul></li><li><p><strong>加入时机</strong>：</p><ul><li>使用 <code>asyncio.sleep()</code> 或 <code>loop.call_later()</code> 等延迟操作时，协程会被添加到调度堆。</li></ul></li></ul><hr><h2 id="调度时机" tabindex="-1"><a class="header-anchor" href="#调度时机"><span>调度时机</span></a></h2><p>协程被添加到调度堆或就绪堆的常见方式包括：</p><ol><li><p><strong>asyncio.sleep</strong>**()**：</p><ul><li>当协程调用 <code>await asyncio.sleep(delay)</code> 时，事件循环会将协程封装为一个定时任务，并添加到调度堆中，等待 <code>delay</code> 时间后执行。</li></ul></li><li><p><strong>loop.call_later()</strong>：</p><ul><li>通过 <code>loop.call_later(delay, callback)</code>，事件循环会将回调函数封装为定时任务，并添加到调度堆中。</li></ul></li><li><p><strong>loop.call_at()</strong>：</p><ul><li>通过 <code>loop.call_at(when, callback)</code>，事件循环会将回调函数封装为定时任务，并添加到调度堆中，在指定时间 <code>when</code> 执行。</li></ul></li><li><p><strong>asyncio.create_task()</strong>：</p><ul><li>使用 <code>asyncio.create_task()</code> 创建任务后，任务会在下一次 <code>await</code> 时自动添加到就绪堆。</li></ul></li><li><p><strong>协程嵌套调用</strong>：</p><ul><li>当一个协程 A 中 <code>await</code> 另一个协程 B 时，协程 A 会通过 <code>add_done_callback</code> 方法注册一个唤醒回调。当协程 B 完成时，事件循环会唤醒协程 A 并将其加入就绪堆。</li></ul></li></ol><hr><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p><code>asyncio</code> 的调度机制基于事件循环和协程，通过就绪堆和调度堆管理任务的执行顺序。其核心特点包括：</p><ul><li><strong>协作式调度</strong>：协程通过 <code>await</code> 主动交出控制权，事件循环根据任务状态调度执行。</li><li><strong>高效 I/O 处理</strong>：通过 <code>select</code> 系统调用监听 I/O 事件，避免阻塞。</li><li><strong>灵活的任务管理</strong>：支持定时任务、嵌套协程调用等多种调度方式。</li></ul><p>理解 <code>asyncio</code> 的调度机制有助于编写高效、可维护的异步代码，充分利用 Python 的异步编程能力。</p><hr><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ul><li>Python 官方文档: <a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener noreferrer">https://docs.python.org/3/library/asyncio.html</a></li><li>Asyncio 源码: <a href="https://github.com/python/cpython/tree/main/Lib/asyncio" target="_blank" rel="noopener noreferrer">https://github.com/python/cpython/tree/main/Lib/asyncio</a></li></ul>',31)]))}const r=l(n,[["render",t]]),d=JSON.parse('{"path":"/Python/Asyncio/%E8%B0%83%E5%BA%A6.html","title":"调度","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"事件循环","slug":"事件循环","link":"#事件循环","children":[]},{"level":2,"title":"调度的对象","slug":"调度的对象","link":"#调度的对象","children":[]},{"level":2,"title":"调度结构","slug":"调度结构","link":"#调度结构","children":[]},{"level":2,"title":"就绪堆（Ready Queue）","slug":"就绪堆-ready-queue","link":"#就绪堆-ready-queue","children":[]},{"level":2,"title":"调度堆（Scheduled Heap）","slug":"调度堆-scheduled-heap","link":"#调度堆-scheduled-heap","children":[]},{"level":2,"title":"调度时机","slug":"调度时机","link":"#调度时机","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{},"filePathRelative":"Python/Asyncio/调度.md"}');export{r as comp,d as data};
