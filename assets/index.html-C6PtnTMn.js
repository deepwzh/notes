import{_ as o,c as i,a as s,d as e,b as l,w as n,r as p,o as h,e as a}from"./app-Bli_YVjf.js";const c={};function u(f,t){const r=p("RouteLink");return h(),i("div",null,[t[4]||(t[4]=s('<h1 id="协程" tabindex="-1"><a class="header-anchor" href="#协程"><span>协程</span></a></h1><ul><li><p>C++ 基于汇编实现的协程与 ucontext_t 版本有以下几个区别：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1916713" target="_blank" rel="noopener noreferrer">基于汇编实现的协程可以直接操作函数的上下文，而 ucontext_t 版本需要通过库函数来获取和设置上下文</a><a href="https://cloud.tencent.com/developer/article/1916713" target="_blank" rel="noopener noreferrer">(1)</a><a href="https://blog.csdn.net/m0_47696151/article/details/121297557" target="_blank" rel="noopener noreferrer">(2)</a>。</li><li><a href="https://cloud.tencent.com/developer/article/1916713" target="_blank" rel="noopener noreferrer">基于汇编实现的协程可以更精确地控制栈空间的分配和释放，而 ucontext_t 版本需要依赖系统提供的栈空间</a><a href="https://cloud.tencent.com/developer/article/1916713" target="_blank" rel="noopener noreferrer">(1)</a><a href="https://zhuanlan.zhihu.com/p/349738180" target="_blank" rel="noopener noreferrer">(3)</a>。</li><li><a href="https://blog.csdn.net/m0_47696151/article/details/121297557" target="_blank" rel="noopener noreferrer">基于汇编实现的协程可以更好地适应不同的平台和编译器，而 ucontext_t 版本可能存在兼容性问题，因为 ucontext 库已被标记为过时</a><a href="https://blog.csdn.net/m0_47696151/article/details/121297557" target="_blank" rel="noopener noreferrer">(2)</a><a href="https://zhuanlan.zhihu.com/p/349738180" target="_blank" rel="noopener noreferrer">(3)</a>。</li></ul><p><a href="https://www.cnblogs.com/ink19/p/ucontext.html" target="_blank" rel="noopener noreferrer">根据网上的一些资料，ucontext.h 是 GNU C 库的一个头文件，主要用于用户态下的上下文切换。但是由于 makecontext 中设计的一些问题，该文件已经被标记为过时的</a><a href="https://www.cnblogs.com/ink19/p/ucontext.html" target="_blank" rel="noopener noreferrer">(1)</a>。一些可能的原因是：</p><ul><li><a href="https://blog.csdn.net/qq_44443986/article/details/117739157" target="_blank" rel="noopener noreferrer">ucontext 函数族不符合 POSIX 标准，不具有跨平台性</a><a href="https://blog.csdn.net/qq_44443986/article/details/117739157" target="_blank" rel="noopener noreferrer">(2)</a>。</li><li><a href="https://blog.csdn.net/qq910894904/article/details/41911175" target="_blank" rel="noopener noreferrer">ucontext 函数族在内存管理和异常处理方面存在一些缺陷</a><a href="https://blog.csdn.net/qq910894904/article/details/41911175" target="_blank" rel="noopener noreferrer">(3)</a>。</li><li><a href="https://blog.csdn.net/qq910894904/article/details/41911175" target="_blank" rel="noopener noreferrer">ucontext 函数族的性能比不上其他实现协程的方式，如汇编代码或 switch-case 技巧</a><a href="https://blog.csdn.net/qq910894904/article/details/41911175" target="_blank" rel="noopener noreferrer">(3)</a>。 <a href="https://www.cnblogs.com/ink19/p/ucontext.html" target="_blank" rel="noopener noreferrer">如果需要类似的功能，可以看一下 Boost 提供的 fcontext</a><a href="https://www.cnblogs.com/ink19/p/ucontext.html" target="_blank" rel="noopener noreferrer">(1)</a>，它是一个更加现代和高效的协程库。</li></ul></li><li><p>有栈协程和无栈协程？</p><ul><li>有栈协程：通过保存运行时的堆栈及运行时的上下文来保存运行状态，需要改变调用栈。</li><li>无栈协程：通过闭包或者状态机的方法记录程序的运行状态，不改变调用栈。</li><li>对称协程：各协程之间可以进行执行权的切换。</li><li>非对称协程：有一个中心化的调度器，所有协程都只和调度器进行执行权的切换。</li></ul></li><li><p>有栈协程的实现方式？</p><ul><li>使用 C 标准函数库的 setjmp 和 longjmp 函数</li><li>使用 POSIX 标准中的 ucontext 库，但是这个库已被标记为 obsolete</li><li>使用汇编直接对函数上下文进行操作</li></ul></li><li><p>有哪些三方的协程库？libco?</p><ul><li><a href="https://blog.csdn.net/Tencent_TEG/article/details/119950205" target="_blank" rel="noopener noreferrer">libco 是微信后台大规模使用的 c/c++ 协程库，它支持同步或者异步的写法，也提供了 socket 族函数的 hook，使得后台逻辑服务几乎不用修改逻辑代码就可以完成异步化改造</a><a href="https://blog.csdn.net/Tencent_TEG/article/details/119950205" target="_blank" rel="noopener noreferrer">(1)</a>。</li><li><a href="https://www.zhihu.com/question/52193579" target="_blank" rel="noopener noreferrer">libco 使用共享栈模式来实现协程，即每个线程只有一个栈空间，所有该线程上的协程都共享这个栈空间。这样可以节省内存空间，也可以支持更多的协程</a><a href="https://www.zhihu.com/question/52193579" target="_blank" rel="noopener noreferrer">(2)</a>。</li><li><a href="https://zhuanlan.zhihu.com/p/338767781" target="_blank" rel="noopener noreferrer">libco 使用汇编代码来实现上下文切换，即保存和恢复寄存器和栈指针。libco 支持 x86、x64、arm、arm64 等多种平台</a><a href="https://zhuanlan.zhihu.com/p/338767781" target="_blank" rel="noopener noreferrer">(3)</a>。</li><li><a href="https://zhuanlan.zhihu.com/p/27409164" target="_blank" rel="noopener noreferrer">libco 提供了几个函数接口来创建、恢复和暂停协程。其中 co_create 用于创建一个新的协程；co_resume 用于恢复一个已经暂停的协程；co_yield 用于暂停当前运行的协程；co_poll 用于等待事件发生并调度相应的协程</a><a href="https://zhuanlan.zhihu.com/p/27409164" target="_blank" rel="noopener noreferrer">(4)</a>。</li></ul></li><li><p>C++20 / C++23 的协程了解吗？</p><ul><li>C++20 中的协程是<strong>非对称的、一等对象、无栈</strong>的。非对称意味着有一个中心化的调度器来控制协程之间的转移；一等对象意味着协程可以作为函数参数或返回值；无栈意味着每个协程不需要分配一个固定大小的栈空间。</li><li>C++20 中使用 co_await、co_yield 和 co_return 关键字来标记协程暂停点和恢复点。co_await 用于等待一个异步操作完成；co_yield 用于生成一个值并暂停；co_return 用于返回一个值并结束。</li><li>C++23 可能会提供更高层次的库来支持协程，比如 generator、task、future 等。这样就可以直接使用协程而不需要自己实现底层细节。</li></ul></li></ul><ol><li>基于 ucontext_t 实现协程的具体原理？</li></ol><h2 id="子文档" tabindex="-1"><a class="header-anchor" href="#子文档"><span>子文档</span></a></h2>',4)),e("ul",null,[e("li",null,[l(r,{to:"/Cpp/%E5%8D%8F%E7%A8%8B/test.html"},{default:n(()=>t[0]||(t[0]=[a("test")])),_:1})])]),t[5]||(t[5]=e("h2",{id:"子文档-1",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#子文档-1"},[e("span",null,"子文档")])],-1)),e("ul",null,[e("li",null,[l(r,{to:"/Cpp/%E5%8D%8F%E7%A8%8B/test.html"},{default:n(()=>t[1]||(t[1]=[a("test")])),_:1})])]),t[6]||(t[6]=e("h2",{id:"子文档-2",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#子文档-2"},[e("span",null,"子文档")])],-1)),e("ul",null,[e("li",null,[l(r,{to:"/Cpp/%E5%8D%8F%E7%A8%8B/test.html"},{default:n(()=>t[2]||(t[2]=[a("test")])),_:1})])]),t[7]||(t[7]=e("h2",{id:"子文档-3",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#子文档-3"},[e("span",null,"子文档")])],-1)),e("ul",null,[e("li",null,[l(r,{to:"/Cpp/%E5%8D%8F%E7%A8%8B/test.html"},{default:n(()=>t[3]||(t[3]=[a("test")])),_:1})])])])}const b=o(c,[["render",u]]),g=JSON.parse('{"path":"/Cpp/%E5%8D%8F%E7%A8%8B/","title":"协程","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"子文档","slug":"子文档","link":"#子文档","children":[]},{"level":2,"title":"子文档","slug":"子文档-1","link":"#子文档-1","children":[]},{"level":2,"title":"子文档","slug":"子文档-2","link":"#子文档-2","children":[]},{"level":2,"title":"子文档","slug":"子文档-3","link":"#子文档-3","children":[]}],"git":{},"filePathRelative":"Cpp/协程/README.md"}');export{b as comp,g as data};
