import{_ as a,c as p,a as t,o as i}from"./app-BKDfXaZz.js";const n="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/PqeAb0paFopvG0xcFkocIGTRnMv.png",s="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/JHaLbbNm5oTyP4xK1qhckdG5nef.png",r="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/OH3zbmZv6o6Vr0x9WuIcTpwmnxd.png",c="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/CbmRbckiboI4DVx8MVPcaxr1nTd.png",l="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/BbphbiFkmoMvNixcbK8cxnt1nhe.png",E="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/ZAY5bmVocolYNuxBYR0cYWrfnuc.png",h="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/TxWeb5XR0oGOHYxwmFocn93onhg.png",o="/wiki/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/static/NyJ5bZbwJoj8UzxNmT7cJVC0nig.png",d={};function m(B,e){return i(),p("div",null,e[0]||(e[0]=[t('<h1 id="cpu" tabindex="-1"><a class="header-anchor" href="#cpu"><span>CPU</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>EU: 执行单元</p><p>CU: 控制单元</p><h2 id="多核与多线程" tabindex="-1"><a class="header-anchor" href="#多核与多线程"><span>多核与多线程</span></a></h2><p><img src="'+n+'" alt=""></p><p>多线程共用 EU</p><h3 id="cpu-超线程" tabindex="-1"><a class="header-anchor" href="#cpu-超线程"><span>CPU 超线程</span></a></h3><p>超线程把一个物理 CPU 当成两个逻辑 CPU 使用，使 CPU 可以同时执行多重线程</p><p>其原理是利用单线程无法跑满所有执行单元这一点。通过超线程，可以充分利用各个运算单元</p><p><img src="'+s+'" alt=""></p><p><a href="https://www.intel.cn/content/www/cn/zh/gaming/resources/hyper-threading.html" target="_blank" rel="noopener noreferrer">https://www.intel.cn/content/www/cn/zh/gaming/resources/hyper-threading.html</a></p><h3 id="cpu-多核" tabindex="-1"><a class="header-anchor" href="#cpu-多核"><span>CPU 多核</span></a></h3><p>双核对比单核，在多线程任务下，约有 60% 的性能提升；运行单个单线程程序，双核和单核效果是一样的</p><p><img src="'+r+'" alt=""></p><p><img src="'+c+'" alt=""></p><p><img src="'+l+'" alt=""></p><h2 id="mmu" tabindex="-1"><a class="header-anchor" href="#mmu"><span>MMU</span></a></h2><p><img src="'+E+'" alt=""></p><h2 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存"><span>缓存</span></a></h2><p><img src="'+h+'" alt=""></p><p>缓存分类：</p><ul><li>一级指令缓存（I$）</li></ul><p>● 一级数据缓存（D$）</p><p>● 转译后备缓冲器（TLB）</p><p>● 二级缓存（E$）</p><p>● 三级缓存（可选）</p><p>cpu 缓存使用组相连</p><p>x86 处理器典型的缓存行大小是 64 字节</p><p><a href="https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98#%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/CPU%E7%BC%93%E5%AD%98#%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84</a></p><h3 id="互联" tabindex="-1"><a class="header-anchor" href="#互联"><span>互联</span></a></h3><p>CPU 通过 QPI 互联，比总线更优</p><p><img src="'+o+'" alt=""></p><h2 id="诊断工具" tabindex="-1"><a class="header-anchor" href="#诊断工具"><span>诊断工具</span></a></h2><p>Uptime</p><p>这个值的意义为，平均负载大于 CPU 数量表示 CPU 不足以服务线程，有些线程在等待。如果平均负载小于 CPU 数量，这（很可能）代表还有一些余量，线程可以在它们想要的时候在 CPU 上运行。</p>',36)]))}const u=a(d,[["render",m]]),k=JSON.parse('{"path":"/%E6%9D%82%E9%A1%B9/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/CPU.html","title":"CPU","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"多核与多线程","slug":"多核与多线程","link":"#多核与多线程","children":[{"level":3,"title":"CPU 超线程","slug":"cpu-超线程","link":"#cpu-超线程","children":[]},{"level":3,"title":"CPU 多核","slug":"cpu-多核","link":"#cpu-多核","children":[]}]},{"level":2,"title":"MMU","slug":"mmu","link":"#mmu","children":[]},{"level":2,"title":"缓存","slug":"缓存","link":"#缓存","children":[{"level":3,"title":"互联","slug":"互联","link":"#互联","children":[]}]},{"level":2,"title":"诊断工具","slug":"诊断工具","link":"#诊断工具","children":[]}],"git":{},"filePathRelative":"杂项/组成原理/CPU.md"}');export{u as comp,k as data};
