import{_ as t,c as n,a as r,o}from"./app-BV7amJBm.js";const a={};function s(p,e){return o(),n("div",null,e[0]||(e[0]=[r('<h1 id="rst-的集中情况" tabindex="-1"><a class="header-anchor" href="#rst-的集中情况"><span>RST 的集中情况</span></a></h1><p><a href="https://nestealin.com/bfdc65d1/" target="_blank" rel="noopener noreferrer">TCP 出现 RST 的几种情况 | Nes 的草稿箱</a></p><p>“Connection reset by peer”，该错误和相同之处都是服务器异常关闭了 socket，但和“Connection reset”是有一定区别的： 服务器返回了“RST”时，如果此时客户端正在从 Socket 套接字的输出流中<strong>读数据</strong>则会提示 Connection reset”； 服务器返回了“RST”时，如果此时客户端正在往 Socket 套接字的输入流中<strong>写数据</strong>则会提示“Connection reset by peer”。</p><p>而 Connection reset 和 Connection reset by peer 产生的原因都是因为客户端进入 CLOSE_WAIT 状态， 如果客户端继续在这个 socket 上发送数据， 那么服务端给回 RST 包。 服务端都已经发出 FIN 表示请求关闭了， 你客户端还发数据过去， 有意义么？ 直接给你 RST。</p><p>其实这个问题服务端客户端同理，如果客户端关闭 socket 之后，服务端还在发消息，服务端同样会抛出 Connection reset 异常。</p><p>Tcp 选项</p><p><a href="https://breezetemple.github.io/2019/07/04/tcp-option-SO-LINGER/" target="_blank" rel="noopener noreferrer">tcp 选项 SO_LINGER</a></p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://www.jianshu.com/p/6ce9598d61fb" target="_blank" rel="noopener noreferrer">客户端异常 Connection reset 原因分析</a></p>',9)]))}const i=t(a,[["render",s]]),l=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/RST%E7%9A%84%E9%9B%86%E4%B8%AD%E6%83%85%E5%86%B5.html","title":"RST 的集中情况","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{},"filePathRelative":"计算机网络/TCP/RST的集中情况.md"}');export{i as comp,l as data};
