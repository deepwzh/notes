import{_ as p,c as i,a as c,d as s,b as e,w as l,r as o,o as r,e as t}from"./app-CBMSK_O_.js";const u="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/EesFbxrGXo5vjZxpH8zcjWTRnsb.png",d="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/SlGCb2xZ3owgjZxUtwZcNYBXnXf.png",m="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/HHB1boATtochiFxC5QFcLMGSnkq.png",E="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/CV0ibyFBbo6MOPxn3AUcA1gSn4e.png",k="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/ETbSbHDQHoFf7OxlzwRcOJG3ndh.png",v="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/MOM6boOyJouUqDxEvScctvtLn2g.png",h="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/M57JbW8TjoJF7wxfW4PcFcyqnrg.png",b="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/BH4gbtywFogO6pxywEecmhGanmd.png",B="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/PQYXbpBONoWx8IxqVemcOdWPnSb.png",A="/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/static/HidTbhIVNoLZDyxYEetcDMzVnHh.png",C={};function g(T,n){const a=o("RouteLink");return r(),i("div",null,[n[20]||(n[20]=c('<h1 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><p>TCP 是一个传输层流协议（因此业务侧要处理&quot;粘包&quot;的问题)</p><h2 id="请求头" tabindex="-1"><a class="header-anchor" href="#请求头"><span>请求头</span></a></h2><p><img src="'+u+'" alt=""></p><h3 id="控制位" tabindex="-1"><a class="header-anchor" href="#控制位"><span>控制位</span></a></h3><p><img src="'+d+'" alt=""></p><h3 id="tcp-选项" tabindex="-1"><a class="header-anchor" href="#tcp-选项"><span>TCP 选项</span></a></h3><p><a href="https://www.cnblogs.com/gangzilife/p/9766114.html" target="_blank" rel="noopener noreferrer">socket 选项总结(setsockopt) - tiny~~ - 博客园</a></p><p><img src="'+m+'" alt=""></p><p>其中 Kind 的枚举值</p><p><img src="'+E+'" alt=""></p><h4 id="sack" tabindex="-1"><a class="header-anchor" href="#sack"><span>SACK</span></a></h4><p>选择重传，在 TCP 头的选项中指定多个边界</p><h4 id="tsopt-时间戳选项" tabindex="-1"><a class="header-anchor" href="#tsopt-时间戳选项"><span>TSOPT 时间戳选项</span></a></h4><p>1）计算往返时延 RTT：</p><p>当 a 主机接收到 b 主机发送过来的确认 ack 报文 s2 时，a 主机此时内核时刻为 ta2.</p><p>a 主机从 s2 报文的 timestamp echo 选项中可以解析出该确认 ack 确认的报文的发送时刻为 ta1.</p><p>那么：RTT＝ 接收 ack 报文的时刻－发送报文的时刻 ＝ta2 －ta1.</p><p>ta2 和 ta1 都来自 a 主机的内核，所以不需要在 tcp 连接的两端进行任何时钟同步的操作。</p><p>2）防止回绕的序号：</p><p>我们知道 TCP 报文的序列号只有 32 位，而没增加 2^32 个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽涌来快速的传输数据。例如 1Gb/s 的速率发送报文，则不到 35 秒报文的序号就会重复。这样对 TCP 传输带来混乱的情况。而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。</p><h2 id="连接队列" tabindex="-1"><a class="header-anchor" href="#连接队列"><span>连接队列</span></a></h2><p><img src="'+k+'" alt=""></p><p>服务器端会维护两种队列，处于 SYN_RCVD 状态的半连接队列，而处于 ESTABLISHED 状态但仍未被应用程序 accept 的为全连接队列</p><h3 id="半连接队列" tabindex="-1"><a class="header-anchor" href="#半连接队列"><span>半连接队列</span></a></h3><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的 SYN 包开设一个条目(服务端在接收到 SYN 包的时候，就已经创建了 request_sock 结构，存储在半连接队列中)，该条目表明服务器已收到 SYN 包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于 Syn_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入 ESTABLISHED 状态。</p><blockquote><p>目前，Linux 下默认会进行 5 次重发 SYN-ACK 包，重试的间隔时间从 1s 开始，下次的重试间隔时间是前一次的双倍，5 次的重试时间间隔为 1s, 2s, 4s, 8s, 16s, 总共 31s, 称为 <code>指数退避</code>，第 5 次发出后还要等 32s 才知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP 才会把断开这个连接。由于，SYN 超时需要 63 秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的 SYN 包给 Server(俗称 SYN flood 攻击)，用于耗尽 Server 的 SYN 队列。对于应对 SYN 过多的问题，linux 提供了几个 TCP 参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p></blockquote><p><img src="'+v+'" alt=""></p><h3 id="全连接队列" tabindex="-1"><a class="header-anchor" href="#全连接队列"><span>全连接队列</span></a></h3><p>当第三次握手时，当 server 接收到 ACK 包之后，会进入一个新的叫 accept 的队列。</p><p>当 accept 队列满了之后，即使 client 继续向 server 发送 ACK 的包，也会不被响应，此时 ListenOverflows+1，同时 server 通过 tcp_abort_on_overflow 来决定如何返回，0 表示直接丢弃该 ACK，1 表示发送 RST 通知 client；相应的，client 则会分别返回 <code>read timeout</code> 或者 <code>connection reset by peer</code>。另外，tcp_abort_on_overflow 是 0 的话，server 过一段时间再次发送 syn+ack 给 client（也就是重新走握手的第二步），如果 client 超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept 队列有空闲的时候最终完成连接。若 accept 队列始终满员，则最终客户端收到 RST 包（此时服务端发送 syn+ack 的次数超出了 tcp_synack_retries）。</p><p>服务端仅仅只是创建一个定时器，以固定间隔重传 syn 和 ack 到服务端</p><p><img src="'+h+'" alt=""></p><h2 id="状态机" tabindex="-1"><a class="header-anchor" href="#状态机"><span>状态机</span></a></h2><p><img src="'+b+'" alt=""></p><h2 id="三次握手" tabindex="-1"><a class="header-anchor" href="#三次握手"><span>三次握手</span></a></h2><p><img src="'+B+`" alt=""></p><h3 id="一些问题" tabindex="-1"><a class="header-anchor" href="#一些问题"><span>一些问题</span></a></h3><ol><li>为什么需要握手？</li></ol><ul><li>三次握手的一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。</li><li></li></ul><ol><li>为什么需要三次握手？</li></ol><h3 id="另一些问题" tabindex="-1"><a class="header-anchor" href="#另一些问题"><span>另一些问题</span></a></h3><ul><li>有关 ISN 生成规则：</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">ISN = M + F(localhost, localport, remotehost, remoteport)</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果 ISN 是固定的，攻击者很容易猜出后续的确认号。因此通过一个公式去计算，M 是一个计时器，每隔 4 毫秒加 1。 F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 hash 算法不能被外部轻易推算得出。</p><ul><li>syn flood 攻击</li></ul><h2 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手"><span>四次挥手</span></a></h2><p><img src="`+A+`" alt=""></p><h3 id="一些问题-1" tabindex="-1"><a class="header-anchor" href="#一些问题-1"><span>一些问题</span></a></h3><ol><li>为什么需要挥手？</li><li>为什么需要四次挥手？</li><li>为什么服务端的 FIN 不能跟 ACK 一起发送？</li><li>为什么客户端需要有等待 2MSL 的 TIME-WAIT？如果不等待会怎么样？</li></ol><h2 id="滑动窗口" tabindex="-1"><a class="header-anchor" href="#滑动窗口"><span>滑动窗口</span></a></h2><h2 id="linux-执行步骤" tabindex="-1"><a class="header-anchor" href="#linux-执行步骤"><span>Linux 执行步骤</span></a></h2><p>当外部连接请求到来时，TCP 模块会首先查看 max_syn_backlog，如果处于 SYN_RCVD 状态的连接数目超过这一阈值，进入的连接会被拒绝。根据 tcp_abort_on_overflow 字段来决定是直接丢弃，还是直接 reset.</p><p>从服务端来说，三次握手中，第一步 server 接受到 client 的 syn 后，把相关信息放到半连接队列中，同时回复 syn+ack 给 client. 第三步当收到客户端的 ack, 将连接加入到全连接队列。</p><p>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到 syn 报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第 3 步(ACK)，则会根据 tcp_abort_on_overflow 字段来决定是直接丢弃，还是直接 reset.此时，客户端发送了 ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第 2 步的 syn+ack, 如果这时有数据到来，服务器 TCP 模块会将数据存入队列中。一段时间后，client 端没收到回复，超时，连接异常，client 会主动关闭连接。</p><h2 id="linux-参数配置" tabindex="-1"><a class="header-anchor" href="#linux-参数配置"><span>Linux 参数配置</span></a></h2><p>一些内核参数配置，使用 sysctl</p><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell"><pre><code><span class="line"><span class="token comment"># 缓冲区配置</span></span>
<span class="line">net<span class="token punctuation">.</span>core<span class="token punctuation">.</span>rmem_max <span class="token comment"># 所有类型读的最大套接字缓冲大小</span></span>
<span class="line">net<span class="token punctuation">.</span>core<span class="token punctuation">.</span>wmem_max <span class="token comment"># 所有类型写的最大套接字缓冲大小</span></span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_moderate_rcvbuf = 1 <span class="token comment"># TCP接收缓存是否自动调整</span></span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_rmem = 4096 65536 16777216 <span class="token comment"># TCP读缓冲配置，可使用最小，默认，最大字节数</span></span>
<span class="line"><span class="token comment"># tcp_rmem的最大字节数一定小于rmem_max，因此需要同步调整</span></span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_wmem = 4096 65536 16777216 <span class="token comment"># TCP写缓冲配置，可使用最小，默认，最大字节数</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 连接队列配置</span></span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_max_syn_backlog = 1048576 <span class="token comment"># 半连接队列长度（socket数量）</span></span>
<span class="line">net<span class="token punctuation">.</span>core<span class="token punctuation">.</span>somaxconn = 65535<span class="token comment"># 全连接队列长度，实际的全连接队列长度=min(backlog, somaxconn)</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token comment"># 网卡配置</span></span>
<span class="line">net<span class="token punctuation">.</span>core<span class="token punctuation">.</span>netdev_max_backlog = 1048576 <span class="token comment"># 每CPU 网络设备积压队列长度，为了10GbE 的NIC，这可能需要增加到10 000。</span></span>
<span class="line"></span>
<span class="line"><span class="token comment"># TCP选项配置</span></span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_sack = 1</span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_fack = 1</span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_tw_reuse = 1 <span class="token comment"># TIME-WAIT socket是否复用，依赖于时间戳选项的开启</span></span>
<span class="line">net<span class="token punctuation">.</span>ipv4<span class="token punctuation">.</span>tcp_tw_recycle = 0 <span class="token comment"># 已废弃</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>网卡的一些参数配置</p><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell"><pre><code><span class="line">ifconfig eth0 txqueuelen 10000 <span class="token comment"># 网卡每CPU发送队列长度</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="一些问题-2" tabindex="-1"><a class="header-anchor" href="#一些问题-2"><span>一些问题</span></a></h2><h3 id="有关粘包" tabindex="-1"><a class="header-anchor" href="#有关粘包"><span>有关粘包</span></a></h3><p>原因：</p><ul><li>服务端会使用 tcp nagle 算法，将多个包合并在一起发送</li><li>客户端会一次取到达的多个包</li></ul><p>解决：</p><p>应用层分包，比如设置请求头，里面标识包的长度</p><h2 id="linux-问题排查" tabindex="-1"><a class="header-anchor" href="#linux-问题排查"><span>Linux 问题排查</span></a></h2><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell"><pre><code><span class="line">netstat <span class="token operator">-</span>i </span>
<span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span>
<span class="line">ens192    1500 9970944800      0      0 0      8747927905      0      0      0 BMRU</span>
<span class="line">lo       65536 2322753743      0      0 0      2322753743      0      0      0 LRU</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RX 标识接收队列，TX 标识发送队列，ERR 标识错误，DRP 标识丢弃，OVR 标识溢出（队列满?）</p><h3 id="连接队列满" tabindex="-1"><a class="header-anchor" href="#连接队列满"><span>连接队列满</span></a></h3><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell"><pre><code><span class="line">netstat <span class="token operator">-</span>s <span class="token punctuation">|</span> grep TCPBacklogDrop <span class="token comment"># 特定于 TCP 连接请求丢弃时间，也就是全连接队列溢出，数字一直变大就是有溢出</span></span>
<span class="line"> netstat <span class="token operator">-</span>s <span class="token punctuation">|</span> grep overflowed  <span class="token comment"># 直接各种缓冲区队列是否有溢出，数字一直变大就是有溢出</span></span>
<span class="line"> netstat <span class="token operator">-</span>s<span class="token punctuation">|</span>egrep <span class="token string">&quot;SYNs to LISTEN&quot;</span> <span class="token comment"># 直接查看tcp半链接队列是否有溢出，数字一直变大就是有溢出</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看全连接队列情况</p><div class="language-powershell line-numbers-mode" data-highlighter="prismjs" data-ext="powershell"><pre><code><span class="line">ss <span class="token operator">-</span>lnt</span>
<span class="line">State                  Recv-Q                  <span class="token function">Send-Q</span>                                   Local Address:Port                                    Peer Address:Port                 <span class="token keyword">Process</span></span>
<span class="line">LISTEN                 0                       65535                                        127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:10248                                        0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:<span class="token operator">*</span></span>
<span class="line">LISTEN                 0                       65535                                          0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:32041                                        0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:<span class="token operator">*</span></span>
<span class="line">LISTEN                 0                       65535                                        127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:10249                                        0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:<span class="token operator">*</span></span>
<span class="line">LISTEN                 0                       65535                                     192<span class="token punctuation">.</span>168<span class="token punctuation">.</span>1<span class="token punctuation">.</span>15:7946                                         0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:<span class="token operator">*</span></span>
<span class="line">LISTEN                 0                       65535                                          0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:31243                                        0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:<span class="token operator">*</span></span>
<span class="line">LISTEN                 0                       65535                                        127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1:9099                                         0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0:<span class="token operator">*</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Send-Q, 表示全连接队列最大为 65535, Recv-Q,标识全连接队列当前是 0</p><p>查看半连接队列长度</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token function">netstat</span> <span class="token parameter variable">-natp</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">&quot;127.0.0.1:8888&quot;</span> <span class="token operator">|</span><span class="token function">grep</span> SYN_RECV <span class="token operator">|</span> <span class="token function">wc</span> -</span>
<span class="line"><span class="token comment"># 127.0.0.1:8888 的半连接长度</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>当全连接队列已满</p><ul><li>当 tcp_abort_on_overflow=0，服务 accept 队列满了，客户端发来 ack,服务端直接丢弃该 ACK，此时服务端处于【syn_rcvd】的状态，客户端处于【established】的状态。在该状态下会有一个定时器重传服务端 SYN/ACK 给客户端（不超过 /proc/sys/net/ipv4/tcp_synack_retries 指定的次数，Linux 下默认 5）。超过后，服务器不再重传，后续也不会有任何动作。如果此时客户端发送数据过来，服务端会返回 RST。（这也就是我们的异常原因了）</li><li>当 tcp_abort_on_overflow=1，服务端 accept 队列满了，客户端发来 ack，服务端直接返回 RST 通知 client，表示废掉这个握手过程和这个连接，client 会报 connection reset by peer。</li></ul></li><li><p>如果半连接队列满了</p><ul><li>没有开启 tcp_syncookies(net.ipv4.tcp_syncookies = 1)，则会丢弃；</li><li>开启，？？？</li></ul></li></ul><h3 id="获取-tcp-详细连接信息" tabindex="-1"><a class="header-anchor" href="#获取-tcp-详细连接信息"><span>获取 tcp 详细连接信息</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line">ss <span class="token parameter variable">--options</span> <span class="token parameter variable">--extended</span> <span class="token parameter variable">--memory</span> <span class="token parameter variable">--processes</span> <span class="token parameter variable">--info</span></span>
<span class="line"></span>
<span class="line">  uid:2016 ino:79654650 sk:204 cgroup:/user.slice/user-2016.slice/session-24913.scope <span class="token operator">&lt;</span>-<span class="token operator">&gt;</span></span>
<span class="line">         skmem:<span class="token punctuation">(</span>r0,rb6944643,t0,tb2626560,f0,w0,o0,bl0,d0<span class="token punctuation">)</span> cubic wscale:9,9 rto:204 rtt:0.026/0.007 ato:40 mss:65495 pmtu:65535 rcvmss:65495 advmss:65495 cwnd:10 bytes_sent:2044962 bytes_acked:2044963 bytes_received:90608190 segs_out:62394 segs_in:62355 data_segs_out:27046 data_segs_in:37627 send 202Gbps lastsnd:1948 lastrcv:2376 lastack:1948 pacing_rate 392Gbps delivery_rate 131Gbps delivered:27047 app_limited busy:49700ms reordering:5 rcv_rtt:9.318 rcv_space:154180 rcv_ssthresh:3471469 minrtt:0.014</span>
<span class="line">tcp                     ESTAB                        <span class="token number">0</span>                        <span class="token number">0</span></span>
<span class="line">                                                                               <span class="token number">127.0</span>.0.1:33076                                                    <span class="token number">127.0</span>.0.1:4222</span>
<span class="line"> users:<span class="token variable"><span class="token punctuation">((</span>&quot;flowgame<span class="token operator">-</span>open<span class="token operator">-</span>a&quot;<span class="token punctuation">,</span>pid<span class="token operator">=</span><span class="token number">194253</span><span class="token punctuation">,</span>fd<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">))</span></span> timer:<span class="token punctuation">(</span>keepalive,4.388ms,0<span class="token punctuation">)</span> uid:2016 ino:19790933 sk:205 cgroup:/user.slice/user-2016.slice/session-2810.scope <span class="token operator">&lt;</span>-<span class="token operator">&gt;</span></span>
<span class="line">         skmem:<span class="token punctuation">(</span>r0,rb2227527,t0,tb2626560,f0,w0,o0,bl0,d55525<span class="token punctuation">)</span> cubic wscale:9,9 rto:204 rtt:1.454/2.082 ato:40 mss:22016 pmtu:65535 rcvmss:536 advmss:65495 cwnd:10 bytes_sent:49355 bytes_acked:49356 bytes_received:49604 segs_out:127450 segs_in:120312 data_segs_out:8199 data_segs_in:8199 send <span class="token number">1</span>.21Gbps lastsnd:25732 lastrcv:25732 lastack:10612 pacing_rate <span class="token number">2</span>.42Gbps delivery_rate <span class="token number">19</span>.6Gbps delivered:8200 app_limited busy:14448ms reordering:5 rcv_rtt:110224 rcv_space:44450 rcv_ssthresh:43690 minrtt:0.364</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="最大文件数满" tabindex="-1"><a class="header-anchor" href="#最大文件数满"><span>最大文件数满</span></a></h3><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p><a href="https://www.jianshu.com/p/0daee7488434" target="_blank" rel="noopener noreferrer">网络基础</a></p><p><a href="https://draveness.me/whys-the-design-tcp-time-wait/" target="_blank" rel="noopener noreferrer">为什么 TCP 协议有 TIME_WAIT 状态 - 面向信仰编程</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener noreferrer">“三次握手，四次挥手”你真的懂吗？</a></p><p><a href="https://juejin.cn/post/6993124663878484005" target="_blank" rel="noopener noreferrer">Linux TCP 内核参数设置与调优(详细)! - 掘金</a></p><h2 id="子文档" tabindex="-1"><a class="header-anchor" href="#子文档"><span>子文档</span></a></h2>`,87)),s("ul",null,[s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/RST%E7%9A%84%E9%9B%86%E4%B8%AD%E6%83%85%E5%86%B5.html"},{default:l(()=>n[0]||(n[0]=[t("RST的集中情况")])),_:1})]),n[3]||(n[3]=s("li",null,"[TCP Keepalive](./TCP Keepalive.md)",-1)),n[4]||(n[4]=s("li",null,"[TCP syn flood 攻击](./TCP syn flood 攻击.md)",-1)),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E9%80%89%E9%A1%B9.html"},{default:l(()=>n[1]||(n[1]=[t("TCP选项")])),_:1})]),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/%E7%9B%B8%E5%85%B3%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0.html"},{default:l(()=>n[2]||(n[2]=[t("相关内核参数")])),_:1})])]),n[21]||(n[21]=s("h2",{id:"子文档-1",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#子文档-1"},[s("span",null,"子文档")])],-1)),s("ul",null,[s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/RST%E7%9A%84%E9%9B%86%E4%B8%AD%E6%83%85%E5%86%B5.html"},{default:l(()=>n[5]||(n[5]=[t("RST的集中情况")])),_:1})]),n[8]||(n[8]=s("li",null,"[TCP Keepalive](./TCP Keepalive.md)",-1)),n[9]||(n[9]=s("li",null,"[TCP syn flood 攻击](./TCP syn flood 攻击.md)",-1)),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E9%80%89%E9%A1%B9.html"},{default:l(()=>n[6]||(n[6]=[t("TCP选项")])),_:1})]),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/%E7%9B%B8%E5%85%B3%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0.html"},{default:l(()=>n[7]||(n[7]=[t("相关内核参数")])),_:1})])]),n[22]||(n[22]=s("h2",{id:"子文档-2",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#子文档-2"},[s("span",null,"子文档")])],-1)),s("ul",null,[s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/RST%E7%9A%84%E9%9B%86%E4%B8%AD%E6%83%85%E5%86%B5.html"},{default:l(()=>n[10]||(n[10]=[t("RST的集中情况")])),_:1})]),n[13]||(n[13]=s("li",null,"[TCP Keepalive](./TCP Keepalive.md)",-1)),n[14]||(n[14]=s("li",null,"[TCP syn flood 攻击](./TCP syn flood 攻击.md)",-1)),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E9%80%89%E9%A1%B9.html"},{default:l(()=>n[11]||(n[11]=[t("TCP选项")])),_:1})]),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/%E7%9B%B8%E5%85%B3%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0.html"},{default:l(()=>n[12]||(n[12]=[t("相关内核参数")])),_:1})])]),n[23]||(n[23]=s("h2",{id:"子文档-3",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#子文档-3"},[s("span",null,"子文档")])],-1)),s("ul",null,[s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/RST%E7%9A%84%E9%9B%86%E4%B8%AD%E6%83%85%E5%86%B5.html"},{default:l(()=>n[15]||(n[15]=[t("RST的集中情况")])),_:1})]),n[18]||(n[18]=s("li",null,"[TCP Keepalive](./TCP Keepalive.md)",-1)),n[19]||(n[19]=s("li",null,"[TCP syn flood 攻击](./TCP syn flood 攻击.md)",-1)),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/TCP%E9%80%89%E9%A1%B9.html"},{default:l(()=>n[16]||(n[16]=[t("TCP选项")])),_:1})]),s("li",null,[e(a,{to:"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/%E7%9B%B8%E5%85%B3%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0.html"},{default:l(()=>n[17]||(n[17]=[t("相关内核参数")])),_:1})])])])}const x=p(C,[["render",g]]),_=JSON.parse('{"path":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/","title":"TCP","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"请求头","slug":"请求头","link":"#请求头","children":[{"level":3,"title":"控制位","slug":"控制位","link":"#控制位","children":[]},{"level":3,"title":"TCP 选项","slug":"tcp-选项","link":"#tcp-选项","children":[]}]},{"level":2,"title":"连接队列","slug":"连接队列","link":"#连接队列","children":[{"level":3,"title":"半连接队列","slug":"半连接队列","link":"#半连接队列","children":[]},{"level":3,"title":"全连接队列","slug":"全连接队列","link":"#全连接队列","children":[]}]},{"level":2,"title":"状态机","slug":"状态机","link":"#状态机","children":[]},{"level":2,"title":"三次握手","slug":"三次握手","link":"#三次握手","children":[{"level":3,"title":"一些问题","slug":"一些问题","link":"#一些问题","children":[]},{"level":3,"title":"另一些问题","slug":"另一些问题","link":"#另一些问题","children":[]}]},{"level":2,"title":"四次挥手","slug":"四次挥手","link":"#四次挥手","children":[{"level":3,"title":"一些问题","slug":"一些问题-1","link":"#一些问题-1","children":[]}]},{"level":2,"title":"滑动窗口","slug":"滑动窗口","link":"#滑动窗口","children":[]},{"level":2,"title":"Linux 执行步骤","slug":"linux-执行步骤","link":"#linux-执行步骤","children":[]},{"level":2,"title":"Linux 参数配置","slug":"linux-参数配置","link":"#linux-参数配置","children":[]},{"level":2,"title":"一些问题","slug":"一些问题-2","link":"#一些问题-2","children":[{"level":3,"title":"有关粘包","slug":"有关粘包","link":"#有关粘包","children":[]}]},{"level":2,"title":"Linux 问题排查","slug":"linux-问题排查","link":"#linux-问题排查","children":[{"level":3,"title":"连接队列满","slug":"连接队列满","link":"#连接队列满","children":[]},{"level":3,"title":"获取 tcp 详细连接信息","slug":"获取-tcp-详细连接信息","link":"#获取-tcp-详细连接信息","children":[]},{"level":3,"title":"最大文件数满","slug":"最大文件数满","link":"#最大文件数满","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]},{"level":2,"title":"子文档","slug":"子文档","link":"#子文档","children":[]},{"level":2,"title":"子文档","slug":"子文档-1","link":"#子文档-1","children":[]},{"level":2,"title":"子文档","slug":"子文档-2","link":"#子文档-2","children":[]},{"level":2,"title":"子文档","slug":"子文档-3","link":"#子文档-3","children":[]}],"git":{},"filePathRelative":"计算机网络/TCP/README.md"}');export{x as comp,_ as data};
