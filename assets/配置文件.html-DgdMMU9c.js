import{_ as s,c as a,a as n,o as l}from"./app-DFLRG_mI.js";const i={};function c(o,e){return l(),a("div",null,e[0]||(e[0]=[n(`<h1 id="配置文件" tabindex="-1"><a class="header-anchor" href="#配置文件"><span>配置文件</span></a></h1><h2 id="有关-shell-配置文件" tabindex="-1"><a class="header-anchor" href="#有关-shell-配置文件"><span>有关 shell 配置文件</span></a></h2><p><code>/etc/profile</code> 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从 <code>/etc/profile.d</code> 目录的配置文件中搜集 shell 的设置。 <code>/etc/bashrc</code> 为每一个运行 bash shell 的用户执行此文件.当 bash shell 被打开时,该文件被读取。 <code>~/.bash_profile</code> 每个用户都可使用该文件输入专用于自己使用的 shell 信息,当用户登录时,该文件仅仅执行一次! 默认情况下,他设置一些环境变量,执行用户的 <code>.bashrc</code> 文件。 <code>~/.bashrc</code> 该文件包含专用于你的 bash shell 的 bash 信息,当登录时以及每次打开新的 shell 时,该该文件被读取。 <code>~/.bash_logout</code> 少见，但是意味着当每次退出系统(退出 bash shell)时,执行该文件。</p><p>另外 <code>/etc/profile</code> 中设定的变量(全局)的可以作用于任何用户, 而 <code>~/.bashrc</code> 等中设定的变量(局部)只能继承 <code>/etc/profile</code> 中的变量,他们是&quot;父子&quot;关系。</p><p><code>profile</code> 用于登录式 shell, 而 <code>bashrc</code> 用于每个交互式 shell <code>~/.bash_profile</code> 是交互式、login 方式进入 bash 运行的 <code>~/.bashrc</code> 是交互式 non-login 方式进入 bash 运行的 通常二者设置大致相同，所以通常前者会调用后者。 所以一般优先把变量设置在 <code>.bashrc</code> 里面。比如在 crontab 里面执行一个命令，<code>.bashrc</code> 设置的环境变量会生效，而 <code>.bash_profile</code> 不会。</p><p>设置生效：可以重启生效，也可以使用命令：<code>source</code></p><p>bash 的一些参数</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">   --noprofile</span>
<span class="line"></span>
<span class="line">          Do not read either the system-wide startup file /etc/profile or  any  of  the  personal  initialization</span>
<span class="line"></span>
<span class="line">          files** ~/.bash_profile, ~/.bash_login, or ~/.profile**.  By default, bash reads these files when it is in‐</span>
<span class="line"></span>
<span class="line">          voked as a login shell (see INVOCATION below).</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"></span>
<span class="line">   --norc Do not read and execute the system wide initialization file /etc/bash.bashrc and the personal  initial‐</span>
<span class="line"></span>
<span class="line">          ization  file  **~/.bashrc** if the shell is interactive.  This option is on by default if the shell is in‐</span>
<span class="line"></span>
<span class="line">          voked as sh.</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When an interactive shell that is not a login shell is started, bash reads and executes commands from <strong>/etc/bash.bashrc and ~/.bashrc</strong>, if these files exist. <strong>This may be inhibited by using the --norc option</strong>. The ** --rcfile file option will force **bash to read and execute commands from file instead of /etc/bash.bashrc and ~/.bashrc.</p>`,9)]))}const t=s(i,[["render",c]]),r=JSON.parse('{"path":"/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/Shell/Bash/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html","title":"配置文件","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"有关 shell 配置文件","slug":"有关-shell-配置文件","link":"#有关-shell-配置文件","children":[]}],"git":{},"filePathRelative":"操作系统/Linux/Shell/Bash/配置文件.md"}');export{t as comp,r as data};
