import{_ as a,c as d,a as r,o as c}from"./app-BCPqHasI.js";const l={};function s(o,e){return c(),d("div",null,e[0]||(e[0]=[r(`<h1 id="docker-镜像打包" tabindex="-1"><a class="header-anchor" href="#docker-镜像打包"><span>docker 镜像打包</span></a></h1><h2 id="以迁移-release-机器的-clang-环境为例" tabindex="-1"><a class="header-anchor" href="#以迁移-release-机器的-clang-环境为例"><span>以迁移 release 机器的 clang 环境为例</span></a></h2><ol><li>从虚拟机的根目录进行打包，排除部分不需要的目录</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">sudo tar -cvpzf system.tar --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/media  --exclude=/pack  --exclude=/home --exclude=/tmp --exclude=/data --exclude=/var/lib/docker /</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>导入文件到 docker 镜像中</li></ol><p>比如将系统包导入到镜像 clang-check-test 中</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker import system.tar clang-check-test</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol><li>运行镜像即可</li></ol><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">docker run -it commit clang-check-test bash</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="扩展知识" tabindex="-1"><a class="header-anchor" href="#扩展知识"><span>扩展知识</span></a></h2><h3 id="docker-load-与-docker-import" tabindex="-1"><a class="header-anchor" href="#docker-load-与-docker-import"><span><code>docker load</code> 与 <code>docker import</code></span></a></h3><h4 id="相同点" tabindex="-1"><a class="header-anchor" href="#相同点"><span>相同点</span></a></h4><p>都是将一个文件导入成镜像</p><h4 id="不同点" tabindex="-1"><a class="header-anchor" href="#不同点"><span>不同点</span></a></h4><ul><li>两者的区别在于容器快照将会丢弃所有的历史记录和元数据信息，而镜像存储文件将保存完整记录，体积也会更大。此外从容器快照文件导入时，也可以重新指定标签等元数据。</li><li>Import 支持导入外部系统的文件结构目录</li></ul><h3 id="docker-save-与-docker-export" tabindex="-1"><a class="header-anchor" href="#docker-save-与-docker-export"><span><code>docker save</code> 与 <code>docker export</code></span></a></h3><h4 id="相同点-1" tabindex="-1"><a class="header-anchor" href="#相同点-1"><span>相同点</span></a></h4><p>都是保存成一个文件，用于迁移</p><h4 id="不同点-1" tabindex="-1"><a class="header-anchor" href="#不同点-1"><span>不同点</span></a></h4><ul><li>将一个镜像导出为文件，再使用 <code>docker load</code> 命令将文件导入为一个镜像，会保存该镜像的的所有历史记录。比 <code>docker export</code> 命令导出的文件大，很好理解，因为会保存镜像的所有历史记录。</li><li><code>docker export container_id</code>：将一个容器导出为文件，再使用 <code>docker import </code> 命令将容器导入成为一个新的镜像，但是相比 <code>docker save</code> 命令，容器文件会丢失所有元数据和历史记录，仅保存容器当时的状态，相当于虚拟机快照。</li></ul>`,20)]))}const i=a(l,[["render",s]]),t=JSON.parse('{"path":"/%E4%BA%91%E5%8E%9F%E7%94%9F/Docker/docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85.html","title":"docker 镜像打包","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"以迁移 release 机器的 clang 环境为例","slug":"以迁移-release-机器的-clang-环境为例","link":"#以迁移-release-机器的-clang-环境为例","children":[]},{"level":2,"title":"扩展知识","slug":"扩展知识","link":"#扩展知识","children":[{"level":3,"title":"docker load 与 docker import","slug":"docker-load-与-docker-import","link":"#docker-load-与-docker-import","children":[]},{"level":3,"title":"docker save 与 docker export","slug":"docker-save-与-docker-export","link":"#docker-save-与-docker-export","children":[]}]}],"git":{},"filePathRelative":"云原生/Docker/docker镜像打包.md"}');export{i as comp,t as data};
