import{_ as e,c as l,a as t,o as r}from"./app-D_qDykLG.js";const i="/wiki/%E6%9D%82%E9%A1%B9/%E5%88%86%E5%B8%83%E5%BC%8F/static/TxB3bdL9EooOzhxveuPcR8Bcnyh.png",n={};function s(h,a){return r(),l("div",null,a[0]||(a[0]=[t('<h1 id="raft-算法" tabindex="-1"><a class="header-anchor" href="#raft-算法"><span>Raft 算法</span></a></h1><h1 id="raft-一致性算法" tabindex="-1"><a class="header-anchor" href="#raft-一致性算法"><span>Raft 一致性算法</span></a></h1><p>有限状态机图</p><p><img src="'+i+'" alt=""></p><h2 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念"><span>基本概念</span></a></h2><ul><li>Leader 领袖</li><li>Candidate 候选人</li><li>Follower 群众</li></ul><h2 id="领袖选举" tabindex="-1"><a class="header-anchor" href="#领袖选举"><span>领袖选举</span></a></h2><ul><li>一开始所有节点都是群众</li><li>会有一个计时器，计时结束后仍没有收到心跳，会将自己设为候选人，任期 +1, 先投自己一票，然后请求别人为自己投票; 如果收到了心跳，会重置计时器</li><li>其他的群众接收到请求投票的消息，若他还没有投票，且请求方的任期比自己本地的要大，会把自己的一票发给第一个投票请求；否则要明确不投票给他</li><li>当一个候选人获取到半数以上的投票，则他将成为 Leader，并通过心跳通告给其他节点，候选人接收到任期更高的心跳转为群众，群众接收到心跳就会重置选举定时器</li></ul><h2 id="日志复制" tabindex="-1"><a class="header-anchor" href="#日志复制"><span>日志复制</span></a></h2><ul><li><p>每一个客户端的请求都将被解析成一条需要复制状态机执行的指令</p></li><li><p>Leader 现将指令存到日志文件中去</p></li><li><p>并行的向其他节点发起 AppendEntries RPC，要求其复制；如果未返回成功则要一直重试</p></li><li><p>Leader 确保<strong>安全复制</strong>后，将日志应用（提交）到状态机中，向客户端返回执行结果</p><ul><li>一旦领导人创建的条目已经被复制到半数以上的节点上了，那么这个条目就称为可被提交的，为安全</li></ul></li><li><p>Leader 通过心跳，将已提交的索引值返回给其他节点，其他节点根据这个信息，把日志应用到本地状态机</p></li></ul><p>Raft 通过以下机制保证不同节点日志的一致性：</p><ol><li>不同日志的两个条目有相同的索引号和任期号，则存储的命令一致</li><li>不同日志有相同的索引和任期号，则他们之前的所有条目都是完全一样的；因为每次 Follower 追加新日志条目的时候，都会检查前一条（前一条的信息也包含在 RPC 请求当中）</li></ol><h2 id="安全性-qa" tabindex="-1"><a class="header-anchor" href="#安全性-qa"><span>安全性 QA</span></a></h2><h1 id="可用性与时序" tabindex="-1"><a class="header-anchor" href="#可用性与时序"><span>可用性与时序</span></a></h1><h1 id="异常情况" tabindex="-1"><a class="header-anchor" href="#异常情况"><span>异常情况</span></a></h1><h3 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h3><p><a href="https://cloud.tencent.com/developer/article/1525566" target="_blank" rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1525566</a></p><p><a href="https://raft.github.io/raftscope/index.html" target="_blank" rel="noopener noreferrer">Raft Scope</a> Raft 算法模拟</p>',18)]))}const d=e(n,[["render",s]]),c=JSON.parse('{"path":"/%E6%9D%82%E9%A1%B9/%E5%88%86%E5%B8%83%E5%BC%8F/Raft%E7%AE%97%E6%B3%95.html","title":"Raft 算法","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"基本概念","slug":"基本概念","link":"#基本概念","children":[]},{"level":2,"title":"领袖选举","slug":"领袖选举","link":"#领袖选举","children":[]},{"level":2,"title":"日志复制","slug":"日志复制","link":"#日志复制","children":[]},{"level":2,"title":"安全性 QA","slug":"安全性-qa","link":"#安全性-qa","children":[{"level":3,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}]}],"git":{},"filePathRelative":"杂项/分布式/Raft算法.md"}');export{d as comp,c as data};
