import{_ as s,c as a,a as e,o as p}from"./app-BqAJMwWL.js";const t={};function l(c,n){return p(),a("div",null,n[0]||(n[0]=[e(`<h1 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析"><span>逃逸分析</span></a></h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h2><h2 id="默认分配策略" tabindex="-1"><a class="header-anchor" href="#默认分配策略"><span><strong>默认分配策略</strong></span></a></h2><p>在没有逃逸分析的情况下，编译器可能会采用以下保守的默认分配策略：</p><ol><li><strong>局部变量</strong>：通常会分配在<strong>栈</strong>上，但如果编译器<strong>无法确定其生命周期</strong>，则可能会分配在堆上。</li><li><strong>指针变量</strong>：如果局部变量的地址被取出并传递到其他函数，编译器可能会将其分配在堆上。</li><li><strong>闭包捕获的变量</strong>：这些变量通常会分配在堆上，因为闭包可能在函数返回后仍然存在。</li></ol><p>逃逸分析就是，确定哪些变量可以分配在栈上，哪些需要分配在堆上。禁用优化后，更多的变量可能会分配到堆上，增加垃圾收集的负担。</p><p>在 Go 语言中，判断一个对象是分配在栈上还是堆上可以通过查看编译器的逃逸分析结果来实现。Go 编译器提供了一个选项，可以在编译时输出逃逸分析的信息，这样你就可以知道哪些变量是分配在堆上，哪些是分配在栈上。</p><h2 id="使用-gcflags-选项查看逃逸分析结果" tabindex="-1"><a class="header-anchor" href="#使用-gcflags-选项查看逃逸分析结果"><span>使用 <code>gcflags</code> 选项查看逃逸分析结果</span></a></h2><p>你可以使用 <code>-gcflags=&quot;-m&quot;</code> 选项来编译你的程序，并查看编译器输出的逃逸分析信息。具体步骤如下：</p><ol><li><strong>创建一个示例程序</strong>：</li></ol><div class="language-go line-numbers-mode" data-highlighter="prismjs" data-ext="go"><pre><code><span class="line"><span class="token keyword">package</span> main</span>
<span class="line"><span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span></span>
<span class="line">    m <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span></span>
<span class="line">    m<span class="token punctuation">[</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span></span>
<span class="line">    <span class="token keyword">return</span> m</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">createSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span></span>
<span class="line">    s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span></span>
<span class="line">    s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span></span>
<span class="line">    <span class="token keyword">return</span> s</span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    m <span class="token operator">:=</span> <span class="token function">createMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span></span>
<span class="line">    s <span class="token operator">:=</span> <span class="token function">createSlice</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>使用 <strong><strong>gcflags=&quot;-m&quot;</strong></strong> 选项编译程序</strong>：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code><span class="line">go build -gcflags=&quot;-m&quot; main.go</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>查看编译器输出</strong>：</p><p>编译器会输出逃逸分析的信息，类似如下：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line">command-line-arguments</span>
<span class="line">./main.go:6:6: can inline createMap</span>
<span class="line">./main.go:12:6: can inline createSlice</span>
<span class="line">./main.go:7:13: make<span class="token punctuation">(</span>map<span class="token punctuation">[</span>string<span class="token punctuation">]</span>int<span class="token punctuation">)</span> does not escape</span>
<span class="line">./main.go:8:13: m<span class="token punctuation">[</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">]</span> escapes to heap</span>
<span class="line">./main.go:8:13: <span class="token operator">&amp;</span>m<span class="token punctuation">[</span><span class="token string">&quot;key&quot;</span><span class="token punctuation">]</span> escapes to heap</span>
<span class="line">./main.go:13:13: make<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>int, <span class="token number">10</span><span class="token punctuation">)</span> does not escape</span>
<span class="line">./main.go:14:13: s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> escapes to heap</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释编译器输出</p><ul><li><strong>does not escape</strong>：表示变量没有逃逸，通常会分配在栈上。</li><li><strong>escapes to heap</strong>：表示变量逃逸了，通常会分配在堆上。</li></ul><p>在上述输出中：</p><ul><li><code>make(map[string]int) does not escape</code> 表示 <code>map</code> 的初始化没有逃逸，可能会分配在栈上。</li><li><code>m[&quot;key&quot;] escapes to heap</code> 表示 <code>map</code> 的元素访问逃逸了，导致 <code>map</code> 被分配在堆上。</li><li><code>make([]int, 10) does not escape</code> 表示 <code>slice</code> 的初始化没有逃逸，可能会分配在栈上。</li><li><code>s[0] escapes to heap</code> 表示 <code>slice</code> 的元素访问逃逸了，导致 <code>slice</code> 的底层数组被分配在堆上。</li></ul>`,20)]))}const i=s(t,[["render",l]]),u=JSON.parse('{"path":"/Golang/%E7%BC%96%E8%AF%91%E5%99%A8/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90.html","title":"逃逸分析","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"默认分配策略","slug":"默认分配策略","link":"#默认分配策略","children":[]},{"level":2,"title":"使用 gcflags 选项查看逃逸分析结果","slug":"使用-gcflags-选项查看逃逸分析结果","link":"#使用-gcflags-选项查看逃逸分析结果","children":[]}],"git":{},"filePathRelative":"Golang/编译器/逃逸分析.md"}');export{i as comp,u as data};
