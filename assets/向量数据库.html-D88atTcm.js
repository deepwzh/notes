import{_ as t,c as n,a as e,o as r}from"./app-BCPqHasI.js";const l={};function s(i,a){return r(),n("div",null,a[0]||(a[0]=[e('<h1 id="向量数据库" tabindex="-1"><a class="header-anchor" href="#向量数据库"><span>向量数据库</span></a></h1><h2 id="qdrant" tabindex="-1"><a class="header-anchor" href="#qdrant"><span>Qdrant</span></a></h2><p>Qdrant 支持以下几种相似度计算方法：</p><ol><li><strong>余弦相似度（Cosine Similarity）</strong>：适用于比较向量的方向，而不考虑向量的大小。常用于文本相似度、信息检索等场景。</li><li><strong>欧氏距离（Euclidean Distance）</strong>：适用于度量两点之间的直线距离，考虑向量的大小和方向。常用于几何计算、图像处理等场景。</li><li><strong>点积（Dot Product）</strong>：适用于度量向量的相对位置和方向。常用于线性代数和信号处理等离散数据计算。</li><li><strong>曼哈顿距离（Manhattan Distance）</strong>：适用于度量两点之间的网格距离，适合网格状或离散空间。常用于路径规划、特征工程等场景。</li></ol><h3 id="如何选择相似度计算方法" tabindex="-1"><a class="header-anchor" href="#如何选择相似度计算方法"><span>如何选择相似度计算方法？</span></a></h3><p>选择相似度计算方法时，应根据具体的应用场景和需求来决定：</p><p>• 文本相似度：通常使用余弦相似度，因为它更关注向量的方向而非大小，适合处理文本数据的相似性。</p><p>• 图像处理或几何计算：欧氏距离更适合，因为它直接度量两点之间的直线距离。</p><p>• 离散数据或信号处理：点积可能更合适，因为它能反映向量的相对位置和方向。</p><p>• 网格状或离散空间：曼哈顿距离是更好的选择，因为它适合处理网格状的数据结构。</p>',10)]))}const d=t(l,[["render",s]]),c=JSON.parse('{"path":"/AIGC/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93.html","title":"向量数据库","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"Qdrant","slug":"qdrant","link":"#qdrant","children":[{"level":3,"title":"如何选择相似度计算方法？","slug":"如何选择相似度计算方法","link":"#如何选择相似度计算方法","children":[]}]}],"git":{},"filePathRelative":"AIGC/向量数据库.md"}');export{d as comp,c as data};
